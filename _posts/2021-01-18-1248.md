---
title: "[백준/C++] Guess"
excerpt: "백준 Guess 재귀 풀이"
last_modified_at: 2021-01-18T23:15:00+09:00
categories: algorithm
tag: ["boj", "brute force"]
toc: true
toc_sticky: true
author_profile: false
---

# Guess

문제
Given a sequence of integers, a1, a2, …, an, we define its sign matrix S such that, for 1 ≤ i ≤ j ≤ n, Sij=”+” if ai + … + aj > 0; Sij=”−” if ai + … + aj < 0; and Sij=”0” otherwise. 

For example, if (a1, a2, a3, a4)=( −1, 5, −4, 2), then its sign matrix S is a 4×4 matrix: 

 	1	2	3	4
1	-	+	0	+
2	 	+	+	+
3	 	 	-	-
4	 	 	 	+

We say that the sequence (−1, 5, −4, 2) generates the sign matrix. A sign matrix is valid if it can be generated by a sequence of integers. 

Given a sequence of integers, it is easy to compute its sign matrix. This problem is about the opposite direction: Given a valid sign matrix, find a sequence of integers that generates the sign matrix. Note that two or more different sequences of integers can generate the same sign matrix. For example, the sequence (−2, 5, −3, 1) generates the same sign matrix as the sequence (−1,5, −4,2). 

Write a program that, given a valid sign matrix, can find a sequence of integers that generates the sign matrix. You may assume that every integer in a sequence is between −10 and 10, both inclusive. 

입력
Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case consists of two lines. The first line contains an integer n(1 ≤ n ≤ 10), where n is the length of a sequence of integers. The second line contains a string of n(n+1)/2 characters such that the first n characters correspond to the first row of the sign matrix, the next n−1 characters  to the second row, ..., and the last character to the n-th row. 

출력
Your program is to write to standard output. For each test case, output exactly one line containing a sequence of n integers which generates the sign matrix. If more than one sequence generates the sign matrix, you may output any one of them. Every integer in the sequence must be between −10 and 10, both inclusive. The following shows a sample input with three test cases and its output. 

예제 입력 1

> 4  
> -+0++++--+  

예제 출력 1

> -2 5 -3 1  

# 풀이

-10부터 10까지는 21개이고 최대 10개의 수가 주어질 수 있으므로 최악의 경우 $21^10$이 되버리고 이는 $2^16$을 넘어버린다. 즉, 시간초과
prunning을 좀 해줘야 하는데, 이게 백트레킹이라고 하는 것 같다.
prunning은 trueIfPossible 함수에서 진행된다.

n개의 수를 차례로 만들어나갈 때(재귀로) 숫자 하나를 만듦과 동시에 trueIfPossible함수에서 S[i][j]값과 비교하여 조건을 만족하는지를 판단하고
만족하지 못하는 경우, 바로 false를 리턴하여 직전의 경우로 돌아가게 된다.

시간이 많이 단축될 것이다. 어...빅오표기법으로 시간복잡도를 어떻게 해야할지 잘 감이 안잡히는데 이번주 스터디에서 한 번 물어봐야겠다.

``` c++
#include <iostream>
#include <vector>
using namespace std;

int N;
char S[10][10];
int list[21];
vector<int> ans;

bool trueIfPossible(int index)
{
	if(ans.size() == 0) return true;
	
	for(int i = 0; i < index; ++i) {
		if(S[i][i] == '+' && ans[i] <= 0) return false;
		if(S[i][i] == '-' && ans[i] >= 0) return false;
		if(S[i][i] == '0' && ans[i] != 0) return false;
		int sum = ans[i];
		for(int j = i+1; j < index; ++j) {
			sum += ans[j];
			if(S[i][j] == '+' && sum <= 0) return false;
			if(S[i][j] == '-' && sum >= 0) return false;
			if(S[i][j] == '0' && sum != 0) return false;
		}
	}

	return true;
}

bool dfs(int cnt)
{
	if(!trueIfPossible(cnt)) return false;

	if(cnt == N) {
		for(int i = 0; i < N; ++i)
			cout << ans[i] << ' ';
		return true;
	}

	for(int i = 0; i < 21; ++i) {
		ans.push_back(list[i]);
		if(dfs(cnt + 1)) return true;
		ans.pop_back();
	}

	return false;
}

int main()
{
	int tmp = -10;
	for(int i = 0; i < 21; ++i)
		list[i] = tmp++;

	cin >> N;
	for(int i = 0; i < N; ++i)
		for(int j = i; j < N; ++j)
			cin >> S[i][j];

	dfs(0);

	return 0;
}
```

끝